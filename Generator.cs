//  Copyright (C) 2023 - Present John Roscoe Hamilton - All Rights Reserved
//  You may use, distribute and modify this code under the terms of the MIT license.
//  See the file License.txt in the root folder for full license details.

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Text;

namespace WFCodeGenLib
{
    public static class Generator
    {
        private static string dataClass;
        public static CodeWriter Generate(Compilation comp, ClassDeclarationSyntax cds, out string className)
        {
            bool IsData = false;
            CodeWriter cw = new CodeWriter();
            ClassInfo c = new ClassInfo(comp, cds);
            className = c.Name;
            if (c.BaseClass == "Data") IsData = true;
            List<FieldInfo> fields = new List<FieldInfo>();
            List<FieldInfo> xfields = new List<FieldInfo>();
            foreach (var f in c.Fields)
            {
                if (f.isStatic) continue;
                if (f.isConst) continue;
                if (f.isX)
                {
                    xfields.Add(f);
                    continue;
                }
                if (f.isPrivate) continue;
                if (f.isReadonly) continue;
                if (f.Type.StartsWith("List"))
                {
                    //Note: There is still code that supports List, but it is not being generated. I
                    // have not removed the code because I may want to add it back in later. I don't
                    // see this happening, but I am leaving it in for now.

                    // I decided to remove List support in favor of adding List support to the
                    // DataField field type. The logic being that a DataField will be easy to add UI support for, as they
                    // are pretty much identical to a Record. By removing regular list simplifies the code base by a ton.

                    throw new Exception($"{c.Name}: I removed List from the supported types, use DataField instead");
                    //continue;
                }
                //if (f.isProperty) continue;
                fields.Add(f);
            }
            dataClass = c.Name;
            cw.line = $"/// <auto-generated/>";
            cw.line = "using WFLib;";
            cw.line = "using Godot;";
            cw.line = "using System;";
            cw.line = $"namespace {c.Namespace};";
            foreach (var line in c.Comments)
            {
                cw.line = "// " + line;
            }
            if (IsData)
            {
                cw.line = $"public partial class {c.Name} : Data";
            }
            else
            {
                cw.line = $"public partial class {c.Name} : Record";
            }

            cw.line = "{";
            cw.line = $"protected override void OnBaseConstruct()";
            cw.line = "{";
            cw.line = "Init();";
            cw.line = "}";
            cw.line = $"public override int FieldCount => {fields.Count};";
            if (IsData)
            {
                cw.Add($"public {c.Name} Rent()=>DataFactory<{c.Name}>.Rent();");
                cw.line = $"~{c.Name}() => Dispose();";
                cw.line = "public override void Dispose()";
                cw.line = "{";
                cw.line = $"DataFactory<{c.Name}>.Return(this);";
                cw.line = "base.Dispose();";
                cw.line = "}";
                cw.line = $"public override bool IsRecord => false;";
                //cw.line = $"public partial class DataField : DataField<DataField, Context, {c.Name}>";
                cw.line = $"public partial class DataField : DataField<{c.Name}>";
                cw.Add("{");
                cw.line = "public DataField(int field)";
                cw.line = "{";
                cw.line = "Field=field;";
                cw.line = "}";

                DataFieldBody(cw, fields, xfields);
                cw.Add("}");
            }
            else
            {
                cw.Add($"public {c.Name} Rent()=>RecordFactory<{c.Name}>.Rent();");
                cw.line = $"public override void InitContextFactory()";
                cw.line = "{";
                cw.line = $"Context.InitContextFactory();";
                cw.line = "}";
                cw.line = $"~{c.Name}() => Dispose();";
                cw.line = "public override void Dispose()";
                cw.line = "{";
                cw.line = $"RecordFactory<{c.Name}>.Return(this);";
                cw.line = "base.Dispose();";
                cw.line = "}";
                cw.line = $"public override bool IsRecord => true;";
            }
            ClearMethod(cw, fields, xfields);
            InitMethod(cw, fields, xfields);
            FieldCopy(cw, fields);
            WriteToBufMethod(cw, fields, !IsData);
            ReadFromBufMethod(cw, fields, !IsData);
            IsDefault(cw, fields);
            IsEqual(cw, fields);
            AsString(cw, fields);
            FromString(cw, fields);
            FieldMethods(cw, fields, c.Name);
            if (IsData)
            {
                cw.line = $"public partial class Context : DataContext<{c.Name}>";
            }
            else
            {
                cw.line = $"public partial class Context : RecordContext<{c.Name}>";
            }
            cw.line = "{";
            GenConstructor(cw, fields, xfields, !IsData, c.Name);
            if (IsData)
            {
                GenDataContextBody(cw, c.Name);
            }
            else
            {
                GenRecordContextBody(cw, fields, c.Name);
            }
            //SerializeMethod(cw, fields, IsData);
            cw.line = "}";
            GenFieldClass(cw, fields);
            GenAttribClass(cw, fields);
            if (IsData)
            {
                GenDataUtil(cw, fields, c.Name);
            }
            else
            {
                GenRecordUtil(cw, fields, c.Name);
                GenTable(cw, fields, c.Name);
            }
            cw.line = "}";
            return cw;
        }
        private static void DataFieldBody(CodeWriter cw, List<FieldInfo> fields, List<FieldInfo> xfields)
        {
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.Add($"public {f.FullType} {f.Name} => Data.{f.Name};");
                    continue;
                }
                cw.Add($"public {f.FullType} {f.Name} => Data.{f.Name};");
            }
            for (int i = 0; i < xfields.Count; i++)
            {
                var f = xfields[i];
                if (f.isPrivate) continue;
                if (f.isDataField)
                {
                    cw.Add($"public {f.FullType} {f.Name} => Data.{f.Name};");
                    continue;
                }
                cw.Add($"public {f.FullType} {f.Name} => Data.{f.Name};");
            }
            //cw.Add($"public void WriteToBuf(SerializationBuffer buf) {{  Data.WriteToBuf(buf); }}");
            //cw.Add($"public void ReadFromBuf(SerializationBuffer buf) {{  Data.ReadFromBuf(buf); }}");

        }
        private static void GenFieldClass(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = "public static class FID";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"public const int {f.Name} = {i};";
            }
            cw.line = "}";
        }
        public static string AsLabel(string name)
        {
            var sb = new StringBuilder();
            var s = name.AsSpan();
            if (s.Length < 1) return string.Empty;

            int upperCount = 0;
            int i = 0;
            char pc = 'a';
            while (i < s.Length)
            {
                var c = s[i];
                var nc = i < s.Length - 1 ? s[i + 1] : 'A';
                if (c.IsUpper())
                {
                    if (upperCount == 0 && i > 0 && (pc.NotDigit() || pc.IsDigit() && nc.NotUpper())) sb.Append(' ');
                    if (upperCount > 0 && nc.NotUpper()) sb.Append(' ');
                    upperCount++;
                    sb.Append(c);
                }
                else
                {
                    upperCount = 0;
                    sb.Append(c);
                }
                pc = c;
                i++;
            }
            var r = sb.ToString();
            return r;

        }
        private static void GenAttribClass(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.append = "static object[] Min = { ";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.append = $"{MinVal(f.Type)},";
            }
            cw.append = " };";
            cw.line = "";
            
            
            cw.append = "static object[] Max = { ";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.append = $"{MaxVal(f.Type)},";
            }
            cw.append = " };";
            cw.line = "";

            //cw.line = "static Func<int,bool>[] ValidationFuncs =";
            //cw.line = "{";
            //for (int i = 0; i < fields.Count; i++)
            //{
            //    //var f = fields[i];
            //    cw.line = $"(field)=>{{return true;}},";
            //}
            //cw.line = "};";
            //cw.line = "";




            cw.line = "static string[] FieldLabels =";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"\"{AsLabel(f.Name)}\",";
            }
            cw.line = "};";

            cw.line = "static string[] ColumnLabels =";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"\"{AsLabel(f.Name)}\",";
            }
            cw.line = "};";

            cw.line = "static Dictionary<string, int> FieldIdLookup = new()";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"{{ \"{f.Name}\", {i} }},";
            }
            cw.line = "};";

            cw.line = "static string[] FieldNames =";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"\"{f.Name}\",";
            }
            cw.line = "};";
            

            cw.line = "static string[] TypeNames =";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"\"{f.Type}\",";
            }
            cw.line = "};";
            cw.line = @"public override string[] StaticTypeNames => TypeNames;";


            //public delegate bool ValidationFunc(int field, out string msg);
            //public abstract ValidationFunc[] StaticValidationFuncs { get; }
            cw.line = $"static List<ValidationFunc>[] ValidationFuncs = new List<ValidationFunc>[{fields.Count}];";
            cw.line = @"public override List<ValidationFunc>[] StaticValidationFuncs => ValidationFuncs;";

            //cw.line = "IEditHelper[] EditHelpers =";
            //cw.line = "{";
            //for (int i = 0; i < fields.Count; i++)
            //{
            //    var f = fields[i];
            //    cw.line = "null,";
            //}
            //cw.line = "};";
        }
        private static void GenDataContextBody(CodeWriter cw, string dataName)
        {
            cw.line = $"public static Context Rent() => (Context) DataContextFactory<{dataName}>.Rent();";
            cw.line = $"public override void Dispose()";
            cw.line = "{";
            cw.line = $"DataContextFactory<{dataName}>.Return(this);";
            cw.line = "}";
        }
        private static void GenRecordContextBody(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            cw.line = $"internal static void InitContextFactory() => RecordContextFactory<{dataName}>.SetCreateMethod(()=>new Context(),_setEditById);";
            cw.line = $"static Context()";
            cw.line = "{";
            cw.line = $"InitContextFactory();";
            cw.line = "}";
            cw.line = $"public static Context Rent(int EditByID=-2) => (Context) RecordContextFactory<{dataName}>.Rent(EditByID);";
            cw.line = $"public override Table Table => (Table) table;";
            cw.line = $"public override void Dispose()";
            cw.line = "{";
            //cw.line = $"RecordFactory<{dataName}>.Return(Rec);"; Opps this is wrong - it can't be returned to the pool
            cw.line = $"RecordContextFactory<{dataName}>.Return(this);";
            cw.line = "}";
            GenContextTable(cw, fields, dataName);
        }
        private static void GenTable(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            bool hasKey = false;
            for (int i = 0; i < fields.Count; i++)
            {
                if (fields[i].isKey) hasKey = true;
            }
            cw.line = $"public partial class Table : Table<{dataName}>";
            cw.line = "{";
            if (hasKey)
            {
                for (int i = 0; i < fields.Count; i++)
                {
                    var f = fields[i];
                    if (f.isKey)
                    {
                        cw.line = $"public readonly Key {f.Name}Key;";
                    }
                }

                cw.line = $"public Table()";
                cw.line = "{";
                for (int i = 0; i < fields.Count; i++)
                {
                    var f = fields[i];
                    if (f.isKey)
                    {
                        cw.line = $"{f.Name}Key = new Key(this,FID.{f.Name});";
                    }
                }
                cw.line = "}";
            }
            cw.line = "}";
        }
        private static void GenContextTable(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            bool hasKey = false;
            for (int i = 0; i < fields.Count; i++)
            {
                if (fields[i].isKey) hasKey = true;
            }
            if (hasKey)
            {
                for (int i = 0; i < fields.Count; i++)
                {
                    var f = fields[i];
                    if (f.isKey)
                    {

                        cw.line = $"public Status ReadBy{f.Name}Key({dataName} data)";
                        cw.line = "{";
                        cw.line = $"return Table.{f.Name}Key.Read(data,EditByID);";
                        cw.line = "}";
                    }
                }
            }
            //cw.line = "Table table;";
            //cw.line = "public override Table Table => table;";

        }
        private static void GenConstructor(CodeWriter cw, List<FieldInfo> fields, List<FieldInfo> xfields, bool IsRecord, string dataName)
        {
            cw.line = $"protected override void OnBaseConstruct()";
            cw.line = "{";
            if (!IsRecord) cw.line = $"Data = DataFactory<{dataName}>.Rent();";
            if (IsRecord) cw.line = $"table = TableFactory<Table,{dataName}>.Rent();";
            cw.line = "}";
        }
        private static void FieldMethodStart(CodeWriter cw, string method, string returnEmpty)
        {
            cw.line = $"public override {method}";
            cw.line = "{";
            cw.line = $"if (field < 0 || field >= FieldCount) {returnEmpty}";
        }
        private static void FieldMethods(CodeWriter cw, List<FieldInfo> fields, string dataname)
        {

            //public string FieldName(int fieldIndex)
            //{

            //    return FieldNames[fieldIndex];
            //}
            string emptyString = "return string.Empty;";
            string emptyVoid = "return;";
            string emptyDouble = "return 0;";
            FieldMethodStart(cw, "string FieldName(int field)", emptyString);
            cw.line = "return FieldNames[field];";
            cw.line = "}";
            //public string FieldLabel(int fieldIndex)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return "N/A";
            //    return FieldLabels[fieldIndex];
            //}
            FieldMethodStart(cw, "string FieldLabel(int field)", emptyString);
            cw.line = "return FieldLabels[field];";
            cw.line = "}";
            //public void SetFieldLabel(int fieldIndex, string label)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return;
            //    FieldLabels[fieldIndex] = label;
            //}
            FieldMethodStart(cw, "void FieldLabelSet(int field, string label)", emptyVoid);
            cw.line = "FieldLabels[field] = label;";
            cw.line = "}";
            //public string ColumnLabel(int fieldIndex)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return "N/A";
            //    return ColumnLabels[fieldIndex];
            //}
            FieldMethodStart(cw, "string FieldColumnLabel(int field)", emptyString);
            cw.line = "return ColumnLabels[field];";
            cw.line = "}";
            //public void SetColumnLabel(int fieldIndex, string label)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return;
            //    ColumnLabels[fieldIndex] = label;
            //}
            FieldMethodStart(cw, "void FieldColumnLabelSet(int field, string label)", emptyVoid);
            cw.line = "ColumnLabels[field] = label;";
            cw.line = "}";

            //public void SetFieldMin(int fieldIndex, double min)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return;
            //    Min[fieldIndex] = min;
            //}
            FieldMethodStart(cw, "void FieldMinSet(int field, object min)", emptyVoid);
            cw.line = "Min[field] = min;";
            cw.line = "}";
            //public double FieldMin(int fieldIndex)
            //{
            //    return Min[fieldIndex];
            //}
            FieldMethodStart(cw, "object FieldMin(int field)", emptyDouble);
            cw.line = "return Min[field];";
            cw.line = "}";
            //public void SetFieldMax(int fieldIndex, double max)
            //{
            //    if (fieldIndex < 0 || fieldIndex >= fieldCount) return;
            //    Min[fieldIndex] = max;
            //}
            FieldMethodStart(cw, "void FieldMaxSet(int field, object max)", emptyVoid);
            cw.line = "Max[field] = max;";
            cw.line = "}";
            //public double FieldMax(int fieldIndex)
            //{
            //    return Max[fieldIndex];
            //}
            FieldMethodStart(cw, "object FieldMax(int field)", emptyDouble);
            cw.line = "return Max[field];";
            cw.line = "}";

            cw.line = "public override int FieldIdFromName(string name)";
            cw.line = "{";
            cw.line = "if (FieldIdLookup.TryGetValue(name, out int id)) return id;";
            cw.line = "return -1;";
            cw.line = "}";

            AsKey(cw, fields);
            AsObject(cw, fields, dataname);
            AsType(cw, fields);

            //cw.line = "private int[] ValidationMessageId =";
            //cw.line = "{";
            //for (int i = 0; i < fields.Count; i++)
            //{
            //    //var f = fields[i];
            //    cw.line = $"0,";
            //}
            //cw.line = "};";
            //cw.line = "";



            //cw.line = "public override bool FieldValidate(int field)";
            //cw.line = "{";
            //cw.line = $"ValidationMessageId[field] = 0;";
            //cw.line = $"return ValidationFuncs[field].Invoke(field);";
            //cw.line = "}";
            //cw.line = "";

            //cw.line = "public override string FieldValidationMessage(int field)";
            //cw.line = "{";
            //cw.line = $"return Validation.Message[ValidationMessageId[field]];";
            //cw.line = "}";
            //cw.line = "";


        }
        private static void AsKey(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line =
            """
            /// <summary>
            /// Writes to sb the field formated as a key.
            /// maxSize is used for strings only.
            /// </summary>
            """;


            cw.line = $"public override void FieldAsKey(int field, SerializationBuffer sb, int maxSize)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isEnum)
                {
                    cw.line = $"{f.Name}.ToString().AsKey(sb,maxSize); return;";
                    continue;
                }
                if (f.Type == "string")
                {
                    cw.line = $"{f.Name}.AsKey(sb, maxSize); return;";
                    continue;
                }
                if (f.isDataField)
                {
                    cw.line = $"return; // DataField as key is not supported";
                    continue;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = $"return; // List as key is not supported";
                    continue;
                }
                if (f.Type.StartsWith("RecID"))
                {
                    cw.line = $"sb.Write({f.Name}.ID); return;";
                    continue;
                }
                cw.line = $"sb.Write({f.Name}); return;";
                continue;
            }
            cw.line = "}";
            cw.line = "}";
        }
        private static void AsObject(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            cw.line =
            """
            /// <summary>
            /// Returns the field as an object.
            /// </summary>
            """;
            cw.line = $"public override Object FieldAsObject(int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                cw.line = $"return (Object){f.Name};";
                continue;
            }
            cw.line = "}";
            cw.line = "return null;";
            cw.line = "}";


            cw.line =
           """
            /// <summary>
            /// Sets the field to an object.
            /// </summary>
            """;
            cw.line = $"public override void FieldFromObject(Object o,  int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"{f.Name} = ({f.FullType}) o; return;";
                    continue;
                }

                cw.line = $"{f.Name} = ({f.Type}) o; return;";
                continue;
            }
            cw.line = "}";
            cw.line = "}";
        }
        private static void AsType(CodeWriter cw, List<FieldInfo> fields)
        {

            cw.line =
            """
            /// <summary>
            /// Returns the field Type.
            /// </summary>
            """;
            cw.line = $"public override Type FieldType(int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                cw.line = $"return {f.Name}.GetType();";
                continue;
            }
            cw.line = "}";
            cw.line = "return null;";
            cw.line = "}";
        }
        private static void AsString(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public override string FieldAsString(int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isEnum)
                {
                    cw.line = $"return {f.Name}.ToString();";
                    continue;
                }
                if (f.Type == "string")
                {
                    cw.line = $"return {f.Name};";
                    continue;
                }

                cw.line = $"return {f.Name}.AsString();";
                continue;
            }
            cw.line = "}";
            cw.line = "return string.Empty;";
            cw.line = "}";
        }
        private static void FromString(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public override void FieldFromString(string str, int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isEnum)
                {
                    cw.line = $"if (!Enum.TryParse<{f.Type}>(str, out {f.Type} {f.Name})) {f.Name} = default; return;";
                    continue;
                }
                if (f.isDataField)
                {
                    cw.line = $"{f.Name}.FromString(str); return;";
                    continue;
                }
                if (f.Type == "string")
                {
                    cw.line = $"{f.Name} = str; return;";
                    continue;
                }
                if (f.Type.StartsWith("RecID"))
                {
                    cw.line = $"{f.Name}.ID = str.AsInt(); return;";
                    continue;
                }
                cw.line = $"{f.Name} = str.{AsName(f.Type)}(); return;";
                continue;
            }
            cw.line = "}";
            cw.line = "return;";
            cw.line = "}";
        }
        private static void IsEqual(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public override bool FieldIsEqual(Data toFld, int field)";
            cw.line = "{";
            cw.line = $"if (!(toFld is {dataClass} to)) return false;";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"return {f.Name}.IsEqualTo(to.{f.Name});";
                    continue;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = "";
                    cw.line = "{";
                    cw.line = $"if ({f.Name}.Count != to.{f.Name}.Count) return false;";
                    cw.line = $"for (int i = 0; i < {f.Name}.Count; i++)";
                    cw.line = "{";
                    cw.line = $"if ({f.Name}[i] != to.{f.Name}[i]) return false;";
                    cw.line = "}";
                    cw.line = $"return true;";
                    cw.line = "}";
                    continue;
                }
                cw.line = $"return {f.Name} == to.{f.Name};";
            }
            cw.line = "}";
            cw.line = "return false;";
            cw.line = "}";
        }
        private static void FieldCopy(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public override void CopyTo(Data toData)";
            cw.line = "{";
            cw.line = $"if (!(toData is {dataClass} to)) return;";
            cw.line = $"to.Clear();";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"{f.Name}.CopyTo(to.{f.Name});";
                    continue;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = $"to.{f.Name}.AddRange({f.Name});";
                    continue;
                }
                cw.line = $"to.{f.Name} = {f.Name};";
            }
            cw.line = "}";
            cw.line = $"public override void FieldCopyTo(Data toData, int field)";
            cw.line = "{";
            cw.line = $"if (!(toData is {dataClass} to)) return;";
            //cw.line = $"to.Clear();";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"{f.Name}.CopyTo(to.{f.Name}); return;";
                    continue;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = $"to.{f.Name}.Clear(); to.{f.Name}.AddRange({f.Name}); return;";
                    continue;
                }
                cw.line = $"to.{f.Name} = {f.Name}; return;";
            }
            cw.line = "}";
            cw.line = "}";
        }
        private static void IsDefault(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public override bool FieldIsDefault(int field)";
            cw.line = "{";
            cw.line = "switch(field)";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                cw.append = $"case {i}:";
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"return {f.Name}.IsDefault();";
                    continue;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = $"return {f.Name}.Count == 0;";
                    continue;
                }
                if (f.Type.StartsWith("RecID"))
                {
                    cw.line = $"return {f.Name}.ID == 0;";
                    continue;
                }
                if (f.Type == "Color")
                {
                    cw.line = $"return {f.Name} == Colors.Black;";
                    continue;
                }
                if (f.Type == "string")
                {
                    cw.line = $"return {f.Name} == string.Empty;";
                    continue;
                }
                if (f.Type == "Quaternion")
                {
                    cw.line = $"return {f.Name} == Quaternion.Identity;";
                    continue;
                }
                cw.line = $"return {f.Name} == default;";
            }
            cw.line = "}";
            cw.line = "return false;";
            cw.line = "}";
        }
        private static string NotDefault(FieldInfo f)
        {
            if (f.isDataField)
            {
                return ($"!data.{f.Name}.IsDefault()");
            }
            if (f.Type.StartsWith("List"))
            {
                return $"data.{f.Name}.Count != 0";
            }
            if (f.Type.StartsWith("RecID"))
            {
                return $"data.{f.Name}.ID != 0";
            }
            if (f.Type == "Color")
            {
                return $"data.{f.Name} != Colors.Black";
            }
            if (f.Type == "Quaternion")
            {
                return $"data.{f.Name} != Quaternion.Identity";
            }

            return $"data.{f.Name} != default";
        }
        private static void InitMethod(CodeWriter cw, List<FieldInfo> fields, List<FieldInfo> xfields)
        {
            cw.line = $"public override void Init()";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (f.isDataField)
                {
                    if (f.Initialization.Length > 0)
                    {
                        cw.line = $"{f.Name} {f.Initialization};";
                    }
                    else
                    {
                        cw.line = $"if ({f.Name} == null) ";
                        cw.line = "{";
                        cw.line = $"{f.Name} = new({i});";
                        //cw.line = $"{f.Name}.Field = {i};";
                        cw.line = "}";
                        cw.line = $"{f.Name}.Init();";
                    }
                    continue;
                }
                if (f.Initialization.Length > 0)
                {
                    cw.line = $"{f.Name} {f.Initialization};";
                }
                else
                {
                    CreateClearMethod(cw, f);
                }
            }
            for (int i = 0; i < xfields.Count; i++)
            {
                var f = xfields[i];
                if (f.isProperty && !f.isAutoProperty)
                {
                    //cw.line = $"(data) => {{}},"; //Do nothing
                    continue;
                }
                if (f.isDataField)
                {
                    cw.line = $"{f.Name}.Init();";
                    continue;
                }
                if (f.Initialization.Length > 0)
                {
                    cw.line = $"{f.Name} {f.Initialization};";
                }
                else
                {
                    CreateClearMethod(cw, f);
                }
            }
            cw.line = "OnInitialize();";
            cw.line = "}";
        }
        private static void ClearMethod(CodeWriter cw, List<FieldInfo> fields, List<FieldInfo> xfields)
        {
            cw.line = $"public override void Clear()";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"if ({f.Name} == null)";
                    cw.line = "{";
                    cw.line = $"{f.Name} = new({i});";
                    //cw.line = $"{f.Name}.Field = {i};";
                    cw.line = "}";
                    cw.line = $"{f.Name}.Clear();";
                    continue;
                }
                CreateClearMethod(cw, f);
            }
            for (int i = 0; i < xfields.Count; i++)
            {
                var f = xfields[i];
                if (f.isProperty && !f.isAutoProperty)
                {
                    //cw.line = $"(data) => {{}},"; //Do nothing
                    continue;
                }
                if (f.isDataField)
                {
                    if (f.Initialization.Length > 0)
                    {
                        cw.line = $"{f.Name} {f.Initialization};";
                    }
                    else
                    {
                        cw.line = $"{f.Name}.Clear();";
                    }
                    continue;
                }
                if (f.Initialization.Length > 0)
                {
                    cw.line = $"{f.Name} {f.Initialization};";
                }
                else
                {
                    CreateClearMethod(cw, f);
                }
            }
            cw.line = "OnClear();";
            cw.line = "}";
        }
        private static string NotDefaultX(FieldInfo f)
        {
            if (f.isDataField)
            {
                return ($"!{f.Name}.IsDefault()");
            }
            if (f.Type.StartsWith("List"))
            {
                return $"{f.Name}.Count != 0";
            }
            if (f.Type.StartsWith("RecID"))
            {
                return $"{f.Name}.ID  != 0";
            }
            if (f.Type == "Color")
            {
                return $"{f.Name} != Colors.Black";
            }
            if (f.Type == "Quaternion")
            {
                return $"{f.Name} != Quaternion.Identity";
            }

            return $"{f.Name} != default";
        }
        private static void WriteToBufMethod(CodeWriter cw, List<FieldInfo> fields, bool isRecord)
        {
            void WriteField(FieldInfo f, int i)
            {
                if (f.isEnum)
                {
                    cw.line = $"sb.Write((byte){f.Name});";
                }
                else if (f.isDataField)
                {
                    cw.line = $"{f.Name}.WriteToBuf(sb);";
                }
                else
                {
                    cw.line = $"sb.Write({f.Name});";
                }
            }
            
            cw.line = $"public override void WriteToBuf(SerializationBuffer sb, bool append=false)";
            cw.line = "{";
            cw.line = "if (!append) sb.Clear();";
            int i = 0;
            if (isRecord)
            {
                for (; i < 4; i++)
                {
                    var f = fields[i];
                    WriteField(f, i);
                }
            }
            for (; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"if ({NotDefaultX(f)})";
                cw.line = "{";
                cw.line = $"sb.WriteSize({i});";
                WriteField(f, i);
                cw.line = "}";
            }
            cw.line = "sb.WriteSize(-1);";
            cw.line = "}";
        }
        private static void ReadFromBufMethod(CodeWriter cw, List<FieldInfo> fields, bool isRecord)
        {
            //void SkipField(FieldInfo f, int i)
            //{
            //    if (f.isDataField)
            //    {
            //        cw.line = $"{f.Name}.Skip(sb);";
            //        return;
            //    }
            //    cw.line = $"sb.Skip({f.Name});";
            //}
            void ReadField(FieldInfo f, int i)
            {
                if (f.isEnum)
                {
                    cw.line = $"{f.Name} = ({f.Type}) sb.ReadByte();";
                    return;
                }
                if (f.isDataField)
                {
                    cw.line = $"{f.Name}.ReadFromBuf(sb);";
                    return;
                }
                if (f.Type.StartsWith("List"))
                {
                    cw.line = $"sb.Read({f.Name});";
                    return;
                }
                if (f.Type.StartsWith("RecID"))
                {
                    cw.line = $"{f.Name}.ID = sb.ReadInt();";
                    return;
                }
                if (f.isProperty)
                {
                    cw.line = $"{f.Name} = sb.Read{TypeName(f.Type)}();";
                    return;
                }
                cw.line = $"sb.Read(out {f.Name});";
            }

            cw.line =
            """
            /// <summary>
            /// ReadFromBuf loads the data from the buffer into the object. 
            /// maxField is used by Table.Filter to only load the fields that are needed.
            /// </summary>
            """;
            cw.line = $"public override void ReadFromBuf(SerializationBuffer sb, int maxField)";
            cw.line = "{";
            cw.line = "Clear();";
            cw.line = "int fieldIndex;";
            int i = 0;
            if (isRecord)
            {
                for (; i < 4; i++)
                {
                    var f = fields[i];
                    if (i > 1) cw.line = $"if (maxField < {i}) return; // no need to do OnLoad we are in a filter";
                    ReadField(f, i);
                }
            }
            cw.line = $"fieldIndex = sb.ReadSize();";
            cw.line = $"if (fieldIndex > maxField) return; ";
            for (; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"if (fieldIndex == {i})";
                cw.line = "{";
                ReadField(f, i);
                cw.line = $"fieldIndex = sb.ReadSize();";
                cw.line = $"if (fieldIndex > maxField) return;";
                cw.line = "}";
            }
            cw.line = "// no need to do OnLoad we are in a filter";
            cw.line = "}";



            cw.line =
           """
            /// <summary>
            /// ReadFromBuf loads the data from the buffer into the object. 
            /// </summary>
            """;
            cw.line = $"public override void ReadFromBuf(SerializationBuffer sb)";
            cw.line = "{";
            cw.line = "Clear();";
            cw.line = "int fieldIndex;";
            i = 0;
            if (isRecord)
            {
                for (; i < 4; i++)
                {
                    var f = fields[i];
                    ReadField(f, i);
                }
            }
            cw.line = $"fieldIndex = sb.ReadSize();";
            for (; i < fields.Count; i++)
            {
                var f = fields[i];
                cw.line = $"if (fieldIndex == {i})";
                cw.line = "{";
                ReadField(f, i);
                cw.line = $"fieldIndex = sb.ReadSize();";
                cw.line = "}";
            }
            cw.line = "OnLoad();";
            cw.line = "}";
        }
        private static void ClearActions(CodeWriter cw, List<FieldInfo> fields)
        {
            cw.line = $"public static Action<{dataClass}>[] ClearActions =";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (f.isDataField)
                {
                    cw.line = $"(data) => ";
                    cw.line = "{";
                    cw.line = $"if (data.{f.Name} == null) data.{f.Name} = new();";
                    cw.line = $"data.{f.Name}.Clear();";
                    cw.line = "},";

                    continue;
                }
                CreateClearAction(cw, f);
            }
            cw.line = "};";

        }
        public const int IntSafeFloatMax = 16_777_217;
        public const int IntSafeFloatMin = -16_777_217;
        public const long IntSafeDoubleMax = 9_007_199_254_740_992;
        public const long IntSafeDoubleMin = -9_007_199_254_740_992;
        private static string MinVal(string type)
        {

            switch (type)
            {
                case Types.DateTime:
                case Types.DateTimeList:
                    var d = DateTime.MinValue;
                    return $"(long) {d.ToBinary().ToString()}"; 
                case Types.Byte:
                    return $"(byte) 0";
                case Types.ShortList:
                case Types.Short:
                    return $"(short) {short.MinValue}";
                case Types.UShortList:
                case Types.UShort:
                    return $"(ushort) {ushort.MinValue}";

                case Types.IntList:
                case Types.Int:
                    return $"(int) {int.MinValue}";
                case Types.UIntList:
                case Types.UInt:
                    return $"(uint) {uint.MinValue}";
                case Types.LongList:
                case Types.Long:
                    return $"(long) {long.MinValue}";
                case Types.ULongList:
                case Types.ULong:
                    return $"(ulong) {ulong.MinValue}";
                case Types.FloatList:
                case Types.Float:
                    return $"(float) {IntSafeFloatMin}";
                case Types.DoubleList:
                case Types.Double:
                    return $"(double) {IntSafeDoubleMin}";
                case Types.DecimalList:
                case Types.Decimal:
                    return $"(decimal) {IntSafeDoubleMin}";
                case Types.Vector2List:
                case Types.Vector2:
                case Types.Vector3List:
                case Types.Vector3:
                case Types.Quaternion:
                case Types.QuaternionList:
                    return $"(float) {IntSafeFloatMin}";
                case Types.Vector2IList:
                case Types.Vector2I:
                case Types.Vector3IList:
                case Types.Vector3I:
                case Types.Vector4IList:
                case Types.Vector4I:
                    return $"(int) {int.MinValue}";
                default:
                    return $"(int) 0";
            }
        }
        private static string MaxVal(string type)
        {
            switch (type)
            {
                case Types.DateTime:
                case Types.DateTimeList:
                    return $"(long) {DateTime.MaxValue.ToBinary()}";
                case Types.Byte:
                    return $"(byte) {byte.MaxValue}";
                case Types.ShortList:
                case Types.Short:
                    return $"(short) {short.MaxValue}";
                case Types.UShortList:
                case Types.UShort:
                    return $"(ushort) {ushort.MaxValue}";
                case Types.IntList:
                case Types.Int:
                    return $"(int) {int.MaxValue}";
                case Types.UIntList:
                case Types.UInt:
                    return $"(uint) {uint.MaxValue}";
                case Types.LongList:
                case Types.Long:
                    return $"(long) {long.MaxValue}";
                case Types.ULongList:
                case Types.ULong:
                    return $"(ulong) {ulong.MaxValue}";
                case Types.FloatList:
                case Types.Float:
                    return $"(float) {IntSafeFloatMax}";
                case Types.DoubleList:
                case Types.Double:
                    return $"(double) {IntSafeDoubleMax}";
                case Types.DecimalList:
                case Types.Decimal:
                    return $"(decimal) {IntSafeDoubleMax}";
                case Types.Vector2List:
                case Types.Vector2:
                case Types.Vector3List:
                case Types.Vector3:
                case Types.Quaternion:
                case Types.QuaternionList:
                    return $"(float) {IntSafeFloatMax}";
                case Types.Vector2IList:
                case Types.Vector2I:
                case Types.Vector3IList:
                case Types.Vector3I:
                case Types.Vector4IList:
                case Types.Vector4I:
                    return $"(int) {int.MaxValue}";
                default:
                    return $"(int) 0";
            }
        }
        private static void CreateClearAction(CodeWriter cw, FieldInfo f)
        {
            if (f.Type.StartsWith("List"))
            {
                cw.line = $"(data) =>";
                cw.line = "{";
                cw.line = $"if (data.{f.Name} == null) data.{f.Name} = new();";
                cw.line = $"data.{f.Name}.Clear();";
                cw.line = "},";
                return;
            }
            if (f.Type.StartsWith("RecID"))
            {
                cw.line = $"(data) =>";
                cw.line = "{";
                cw.line = $"data.{f.Name}.Clear();";
                cw.line = "},";
                return;
            }

            switch (f.Type)
            {
                case "Vector2I":
                    cw.line = $"(data) => data.{f.Name} = Vector2I.Zero,";
                    return;
                case "Vector3I":
                    cw.line = $"(data) => data.{f.Name} = Vector3I.Zero,";
                    return;
                case "Vector4I":
                    cw.line = $"(data) => data.{f.Name} = Vector4I.Zero,";
                    return;
                case "Vector2":
                    cw.line = $"(data) => data.{f.Name} = Vector2.Zero,";
                    break;
                case "Vector3":
                    cw.line = $"(data) => data.{f.Name} = Vector3.Zero,";
                    break;
                case "Quaternion":
                    cw.line = $"(data) => data.{f.Name} = Quaternion.Identity,";
                    break;
                case "DateTime":
                    cw.line = $"(data) => data.{f.Name} = DateTime.MinValue,";
                    break;
                case "bool":
                    cw.line = $"(data) => data.{f.Name} = false,";
                    break;
                case "Color":
                    cw.line = $"(data) => data.{f.Name} = Godot.Colors.Black,";
                    break;
                case "string":
                    cw.line = $"(data) => data.{f.Name} = string.Empty,";
                    break;
                default:
                    cw.line = $"(data) => data.{f.Name} = 0,";
                    break;
            }
        }
        private static void CreateClearMethod(CodeWriter cw, FieldInfo f)
        {
            if (f.Type.StartsWith("List"))
            {
                cw.line = $"if ({f.Name} == null) {f.Name} = new();";
                cw.line = $"{f.Name}.Clear();";
                return;
            }
            if (f.Type.StartsWith("RecID"))
            {
                cw.line = $"{f.Name}.Clear();";
                return;
            }
            switch (f.Type)
            {
                case "Vector2I":
                    cw.line = $"{f.Name} = Vector2I.Zero;";
                    return;
                case "Vector3I":
                    cw.line = $"{f.Name} = Vector3I.Zero;";
                    return;
                case "Vector4I":
                    cw.line = $"{f.Name} = Vector4I.Zero;";
                    return;
                case "Vector2":
                    cw.line = $"{f.Name} = Vector2.Zero;";
                    break;
                case "Vector3":
                    cw.line = $"{f.Name} = Vector3.Zero;";
                    break;
                case "Quaternion":
                    cw.line = $"{f.Name} = Quaternion.Identity;";
                    break;
                case "DateTime":
                    cw.line = $"{f.Name} = DateTime.MinValue;";
                    break;
                case "bool":
                    cw.line = $"{f.Name} = false;";
                    break;
                case "Color":
                    cw.line = $"{f.Name} = Godot.Colors.Black;";
                    break;
                case "string":
                    cw.line = $"{f.Name} = string.Empty;";
                    break;
                default:
                    cw.line = $"{f.Name} = 0;";
                    break;
            }
        }
        private static void GenDataUtil(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            cw.line = $"public partial class Util : DataUtil<{dataName}>";
            cw.line = "{";
            cw.line = "}";
        }
        private static void GenRecordUtil(CodeWriter cw, List<FieldInfo> fields, string dataName)
        {
            cw.line = $"public partial class Util : RecordUtil<{dataName}>";
            cw.line = "{";
            for (int i = 0; i < fields.Count; i++)
            {
                var f = fields[i];
                if (!f.isKey) continue;
                cw.line = $"public static Status ReadBy{f.Name}Key({dataName} data,int EditByID=-2)";
                cw.line = "{";
                cw.line = "var context = (Context) RentContext(EditByID);";
                cw.line = $"var status = context.ReadBy{f.Name}Key(data);";
                //cw.line = "context.Return();";
                cw.line = "return status;";
                cw.line = "}";
            }
            cw.line = "}";
        }
        private static string AsName(string type)
        {
            var typeArray = type.AsSpan();
            if (typeArray.Length == 0)
            {
                return type;
            }
            Span<char> toType = stackalloc char[typeArray.Length];
            typeArray.CopyTo(toType);
            toType[0] = Char.ToUpper(toType[0]);
            var astype = new string(toType.ToArray());
            if (astype.StartsWith("List"))
                astype = FixListType(astype.AsSpan());
            string result = "As" + astype;
            result = result.Replace("Uint", "UInt");
            result = result.Replace("Ushort", "UShort");
            result = result.Replace("Ulong", "ULong");
            return result;
        }
        private static string TypeName(string type)
        {
            var typeArray = type.AsSpan();
            Span<char> toType = stackalloc char[typeArray.Length];
            typeArray.CopyTo(toType);
            toType[0] = Char.ToUpper(toType[0]);
            var astype = new string(toType.ToArray());
            if (astype.StartsWith("List"))
                astype = FixListType(astype.AsSpan());
            string result = astype;
            result = result.Replace("Uint", "UInt");
            result = result.Replace("Ushort", "UShort");
            result = result.Replace("Ulong", "ULong");
            return result;
        }
        private static string FixListType(ReadOnlySpan<char> type)
        {
            int startPos = 0;
            int endPos = type.Length;
            for (int i = 0; i < type.Length; i++)
            {
                if (type[i] == '<') startPos = i + 1;
                if (type[i] == '>') endPos = i - 1;
            }
            var s = type.Slice(startPos, (endPos - startPos) + 1);
            Span<char> caps = stackalloc char[s.Length];
            s.CopyTo(caps);
            caps[0] = Char.ToUpper(caps[0]);
            var newType = $"ListOf{new string(caps.ToArray())}";
            return newType;
        }
    }
}